# pentesting_tools.py
"""
Pentesting tools management and integration module.
"""

import subprocess
import platform
import shutil
import os
from typing import Dict, List, Tuple, Optional
from config import Colors, print_colored

class PentestingToolsManager:
    """Manages installation and integration of pentesting tools."""
    
    def __init__(self):
        self.system = platform.system().lower()
        self.tools_status = {}
        self.tool_commands = {
            # Network Scanning
            'nmap': {
                'install': {
                    'darwin': 'brew install nmap',
                    'linux': 'sudo apt-get update && sudo apt-get install -y nmap',
                    'windows': 'choco install nmap'
                },
                'check': 'nmap --version',
                'category': 'network_scan'
            },
            'masscan': {
                'install': {
                    'darwin': 'brew install masscan',
                    'linux': 'sudo apt-get update && sudo apt-get install -y masscan',
                    'windows': 'Manual installation required'
                },
                'check': 'masscan --version',
                'category': 'network_scan'
            },
            
            # Web Enumeration
            'gobuster': {
                'install': {
                    'darwin': 'brew install gobuster',
                    'linux': 'sudo apt-get update && sudo apt-get install -y gobuster',
                    'windows': 'Manual installation required'
                },
                'check': 'gobuster version',
                'category': 'web_enum'
            },
            'dirb': {
                'install': {
                    'darwin': 'brew install dirb',
                    'linux': 'sudo apt-get update && sudo apt-get install -y dirb',
                    'windows': 'Manual installation required'
                },
                'check': 'dirb',
                'category': 'web_enum'
            },
            'nikto': {
                'install': {
                    'darwin': 'brew install nikto',
                    'linux': 'sudo apt-get update && sudo apt-get install -y nikto',
                    'windows': 'Manual installation required'
                },
                'check': 'nikto -Version',
                'category': 'vuln_scan'
            },
            
            # DNS Tools
            'dig': {
                'install': {
                    'darwin': 'brew install bind',
                    'linux': 'sudo apt-get update && sudo apt-get install -y dnsutils',
                    'windows': 'Manual installation required'
                },
                'check': 'dig -v',
                'category': 'recon'
            },
            'nslookup': {
                'install': {
                    'darwin': 'Built-in',
                    'linux': 'Built-in',
                    'windows': 'Built-in'
                },
                'check': 'nslookup -version || echo "Available"',
                'category': 'recon'
            },
            
            # Web Analysis
            'whatweb': {
                'install': {
                    'darwin': 'brew install whatweb',
                    'linux': 'sudo apt-get update && sudo apt-get install -y whatweb',
                    'windows': 'Manual installation required'
                },
                'check': 'whatweb --version',
                'category': 'web_enum'
            },
            'curl': {
                'install': {
                    'darwin': 'brew install curl',
                    'linux': 'sudo apt-get update && sudo apt-get install -y curl',
                    'windows': 'Built-in (Windows 10+)'
                },
                'check': 'curl --version',
                'category': 'web_enum'
            },
            'wget': {
                'install': {
                    'darwin': 'brew install wget',
                    'linux': 'sudo apt-get update && sudo apt-get install -y wget',
                    'windows': 'Manual installation required'
                },
                'check': 'wget --version',
                'category': 'web_enum'
            },
            
            # Vulnerability Scanners
            'sqlmap': {
                'install': {
                    'darwin': 'brew install sqlmap',
                    'linux': 'sudo apt-get update && sudo apt-get install -y sqlmap',
                    'windows': 'pip install sqlmapapi'
                },
                'check': 'sqlmap --version',
                'category': 'exploitation'
            }
        }
    
    def check_tool_availability(self, tool_name: str) -> bool:
        """Check if a pentesting tool is available."""
        if tool_name not in self.tool_commands:
            return False
        
        try:
            result = subprocess.run(
                self.tool_commands[tool_name]['check'],
                shell=True,
                capture_output=True,
                text=True,
                timeout=10
            )
            available = result.returncode == 0
            self.tools_status[tool_name] = available
            return available
        except:
            self.tools_status[tool_name] = False
            return False
    
    def install_tool(self, tool_name: str) -> Tuple[bool, str]:
        """Install a pentesting tool."""
        if tool_name not in self.tool_commands:
            return False, f"Unknown tool: {tool_name}"
        
        tool_info = self.tool_commands[tool_name]
        if self.system not in tool_info['install']:
            return False, f"Installation not supported on {self.system}"
        
        install_cmd = tool_info['install'][self.system]
        if install_cmd == "Manual installation required":
            return False, f"Manual installation required for {tool_name} on {self.system}"
        
        try:
            print_colored(f"🔧 Installing {tool_name}...", Colors.YELLOW)
            result = subprocess.run(
                install_cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=300  # 5 minutes timeout
            )
            
            if result.returncode == 0:
                print_colored(f"✅ {tool_name} installed successfully", Colors.GREEN)
                self.tools_status[tool_name] = True
                return True, f"{tool_name} installed successfully"
            else:
                error_msg = f"Installation failed: {result.stderr}"
                print_colored(f"❌ {error_msg}", Colors.RED)
                return False, error_msg
                
        except subprocess.TimeoutExpired:
            return False, f"Installation timed out for {tool_name}"
        except Exception as e:
            return False, f"Installation error: {str(e)}"
    
    def get_tools_by_category(self, category: str) -> List[str]:
        """Get tools by category."""
        return [tool for tool, info in self.tool_commands.items() 
                if info['category'] == category]
    
    def check_all_tools(self) -> Dict[str, bool]:
        """Check availability of all tools."""
        print_colored("🔍 Checking pentesting tools availability...", Colors.CYAN, bold=True)
        
        for tool_name in self.tool_commands.keys():
            available = self.check_tool_availability(tool_name)
            status = "✅" if available else "❌"
            print_colored(f"   {status} {tool_name}", 
                         Colors.GREEN if available else Colors.RED)
        
        return self.tools_status
    
    def suggest_tool_installation(self, category: str = None) -> List[str]:
        """Suggest tools to install for a specific category."""
        if category:
            tools = self.get_tools_by_category(category)
        else:
            tools = list(self.tool_commands.keys())
        
        missing_tools = [tool for tool in tools 
                        if not self.tools_status.get(tool, False)]
        
        if missing_tools:
            print_colored(f"💡 Suggested tools to install for {category or 'general'} testing:", 
                         Colors.YELLOW, bold=True)
            for tool in missing_tools:
                print_colored(f"   • {tool}: {self.tool_commands[tool]['install'].get(self.system, 'Manual installation')}", 
                             Colors.LIGHTYELLOW_EX)
        
        return missing_tools

# Global tools manager
tools_manager = PentestingToolsManager()
